Paper:
---------
1. Looking for an edge r_i: h().....
2. Create a new node vec( y ) that matches the city vec(x), and add it between nodes vec(y_i), vec(y_(i+1)).
3. We check if criterion 1 is met. The traversed cities that do not satisfy this criterion are released (i.e., returned to the stack S of untraversed cities) and traversed again.

When a node vec( y ) is added to the route, two new edges (vec(y_i), vec(y)) and (vec( y ), vec(y_(i+1)))) are added. The values of h(vec(y_i)) and h(vec(y_()i+1)) change, so to check if the criterion is fulfilled it is enough to check it for vec(y_i) and vec(y_(i+1)), and to compare h(vec(y_k)) with h(vec(y_k)); vec(y_i), vec(y)) and with h(vec(y_k); vec( y ), vec(y_(i+1)))) for the remaining nodes.
When a node vec(y_k) is removed from the route, we need to check if the criterion is fulfilled given the new edge (vec(y_(k-1)), vec(y_(k+1))) and changed values of h(vec(y_(k-1))) and h(vec(y_(k+1)))).
To ensure that there are no self-intersections in the route, it is sufficient, when adding a node vec( y ) between nodes vec(y_i), vec(y_(i+1)), to first remove all nodes from the route, lying inside the triangle (vec(y)), vec(y_i), vec(y_(i+1))), and when removing node vec(y_i), remove all nodes from the triangle (vec(y)), vec(y_(i-1)), vec(y_(i+1))).

Implementation:
--------------
Let the city indices be:
ci element of [0, num_cities)
Let the node indices be:
ni element of [0, num_nodes)

1. Take a city on stack, x_ci
2. Find nodes y_ni and y_(ni+1) which satisfies step (1) in paper.
3. Remove city x_ci from stack
4. Add new node at (ni+1) which is equal to x_ci and increase by value 1, the indies of node from original (ni+1) and higher. So, (ni+1), (ni+2), (ni+3)...(ni+N) becomes (ni+2), (ni+3), (ni+4)...(ni+N+1)
5. Update cost values of y_ni, y_(ni+1) and y_(ni+2)

6. Check whether y_ni and y_(ni+2) satisfy criterion 1
7. Check whether all other nodes except y_(ni+1) satisfy criterion 1 by comparing with new edges {y_ni, y_(ni+1)} except node y_ni and {y_(ni+1), y_(ni+2)} except node y_(ni+2)
*order invariant impl*
8. Mark all nodes that don't satisfy the criteria for removal.
9. For each node marked for removal construct new edges that will be formed after their removal.
10. The neighbours have to be selected from the two adjacent nodes on the path (those ones not marked for removal) to the left and right of the current node marked for removal
11. Update the node cost of neighbours, check if they satisfy criterion.
12. Compare the node cost of other nodes with the newly formed edges
(this is bad because any of the newly formed edge might invalidate the newly added node. So, all the nodes removed because of the addition of the newly added node doesn't make sense)
*order non-invariant impl*
8. For each node not satisfying the criterion 1, we remove it
9. A new adge is created between its neighbours.
10. Update the node cost of neighbours, check if they satisfy criterion.
11. Compare the node cost of other nodes with the newly formed edges

New Implementation 1:
---
1. For each city we store id of neighbours in the path.
2. For addition of each city in a layer:
    a. Add the node between somewhere among its children
    b. If there are no children, then add to the current path
3. When a node is removed:
    a. If the node has parent then add the node between the children of its parent if it has a parent. Otherwise add among its own children.

New Implementation 2:
---
1. For each city we store id of neighbours in the path.
2. For each city we store the matrix coordinates of the square in its current layer.
3. For each city we store the matrix coordinates of the square in the next layer.
4. For addition of each city in a layer:
    a. If there is a next layer:
        i. Then take cities, from the next layer, in the surrounding squares including the one that it's on.
        ii. if there are less than 2 nodes in the surrounding squares, then use +- 1 to curent range of finding surrounding squares to search
5. When a node is checked for removal:
    a. If the node has parent then add the node between the children of its parent if it has a parent. Otherwise add among its own children.

New Implementation 3:
---
1. For each city we store id of neighbours in the path.
2. For each city we store the matrix coordinates of the square in the final layer.
3. We complete the net for the final layer N.
4. For addition of each city to the path:
    a. Find the neighbours in the path:
        i. Take cities in the surrounding squares including the one that it's on if there are other cities there.
        ii. if there are less than 2 nodes in the surrounding squares, then use +- 1 to curent range of finding surrounding squares to search
    b. Check for best insertion cost in the selected neighbours in the path
    c. After insertion check whether there is any nodes inside the triangle formed by the added node and its neigbours by checking for nodes inside the rectangle formed by (min_coord, min_coord) and (max_coord, max_coord) of the three triangle nodes
5. When a node is checked for removal:
    a. Find neighbours using the same process as mentioned in step 4.a
    b. Check whether the it's cost is still a minimum.


New Implementation 4:
---
1. For each city, find 2 closest cities each in the four direction.
2. Skip the second of the 2 cities if they are collinear
3. Sort the cities based on the score, which is the insertion cost of the city.
4. Find the minimum city
5. From the minimum city, connect to the 2 closest cities with lowest score.
6. Mark this as a parent city.
7. Go to the left or right children city
8. From the sorted edge scores, find the minimum edge with one of the ends as parent.
9. Mark the current child as parent and it
